import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.ArrayList;
import java.util.List;


//command: time java FunWithThreads -threads 1000; time java FunWithThreads -c 1000 -s
public class FunWithThreads {
  
  final Disk disk = new Disk();
  final Args args;
  int        val[];
  
  FunWithThreads (String argsStrings[]) {
    args = new Args (getClass().getName(), argsStrings, Option.values());
  }
  
  /**
   * Command Line Arguments
   */
  
  enum Option implements Args.OptionReferrer {    
    SEQUENTIAL ("-sequential",       "Select sequential implementation"), 
    THREADS    ("-threads",          "Select thread-based implementation"), 
    EXECUTOR   ("-executor",   null, "Select executor implementation where n is number of threads"),
    VERBOSE    ("-verbose",          "Print values generated by read"),
    COUNT      ("-count",      1000, "Number of reads to perform");
    
    final Args.Option option;
    Option (String str, String dsc)              {option = new Args.Option (str, dsc);}
    Option (String str, Integer dfl, String dsc) {option = new Args.Option (str, dfl, dsc);}
    public Args.Option getOption()               {return option;}
  }
  
  /**
   * Called by main to run the class.
   */
  
  void run() throws Args.UsageException, InterruptedException {
    int readCount = args.intValue (Option.COUNT);
    val           = new int [readCount];
    if (args.contains (Option.SEQUENTIAL)) {
      System.out.printf ("Performing %d reads sequentially.\n", readCount);
      sequential (readCount);
    } else if (args.contains (Option.THREADS)) {
      System.out.printf ("Performing %d reads in separate threads.\n", readCount);
      threaded (readCount);
    } else if (args.contains (Option.EXECUTOR)) {
      int threadCount = args.intValue (Option.EXECUTOR);
      System.out.printf ("Performing %d reads using thread-pool executor with %d threads.\n", readCount, threadCount);
      executor (readCount, threadCount);
    } else
      throw args.new UsageException();
    if (args.contains (Option.VERBOSE))
      for (int i=0; i<readCount; i++)
        System.out.printf ("(%d %d)\n", val[i]>>16, val[i]& 0xffff);
  }
  
  /**
   * Execution starts with main, which creates instance of class and calls run.
   */
  
  public static void main (String[] args) {
    try {
      (new FunWithThreads (args)) .run ();
    } catch (Args.UsageException ue) {
      System.out.print (ue.getMessage());
    } catch (InterruptedException ie) {
      System.out.println ("Interruped Exception thrown.");
    }
  }
  
  /**
   * Performs disk reads sequentially.
   * @param  readCount            number of reads to perform
   */
  
  void sequential (int readCount) {
    for (int i=0; i<readCount; i++)
      val [i] = disk.read (i);
  }
  
  /**
   * Perform disk reads using separate thread for each read.
   *
   * @param  readCount            number of reads to perform
   * @throws InterruptedException if join is interrupted    
   */
  
  void threaded (int readCount) throws InterruptedException {
	  List<Thread> thread_list = new ArrayList<>();
	  for (int i = 0; i < readCount; i++) {
		  ReadRunnable r = new ReadRunnable(i);
		  Thread t = new Thread(r);
		  thread_list.add(t);
		  t.start();
	  }
	  for (Thread t: thread_list) {
		  int result;
		  try {
			  t.join(); 
		  }catch(Error e) {
			  ;
		  }
	  }
	  
  }
  
  /**
   * Perform disk reads using thread-pool executor.
   *
   * @param  readCount            number of reads to perform
   * @param  threadCount          number of threads in the thread pool
   * @throws InterruptedException if future-value wait is interrupted    
   */
  
  void executor (int readCount, int threadCount) throws InterruptedException {
    ArrayList <Future <Integer>> futureVals = new ArrayList <Future <Integer>> ();

    ExecutorService exec = Executors.newFixedThreadPool (threadCount);
    for (int i = 0; i < readCount; i++) {
    	// future: the result of an asynchronous computation
    	Future<Integer> resultFuture = exec.submit(new ReadCallable(i)); // submit task
    	futureVals.add(resultFuture);
    }
    
    for (Future<Integer> rf : futureVals) {
    	Integer result = null;
        try {
        	result = rf.get(); // join 
        }catch (ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
     }
    
    
    exec.shutdown();
  }
  
  /**
   * Crude implementation of disk.
   */
  private class ReadRunnable implements Runnable{
	private int index;
	
	public ReadRunnable(int i) {
		this.index = i;
		// System.out.println("new thread created");
	}
	
	@Override
	public void run() {
		// System.out.println("running a thread");
		try{
			val [index] = disk.read (index);
		}catch(Error e) {
			System.out.println("thread interrupted");
		}
		//System.out.println("Thread exiting");
	}
	  
  }
  
  private class ReadCallable implements Callable<Integer>{
	private int index;
	
	public ReadCallable(int i) {
		this.index = i;
	}
	
	@Override
	public Integer call() throws Exception {
		// TODO Auto-generated method stub
		return disk.read(this.index);
	}
	  
  }
  
  static class Disk {
    int count=0;
    /**
     * Simulate a synchronous disk read by waiting 10ms before returning.
     *
     * @param req request sequence number
     * @return    processing sequence number << 16 | request sequence number
     */
    public int read (int req) {
      try {
        Thread.sleep (10);  
      } catch (InterruptedException ie) {
        assert false;
      }
      return (count++)<<16 | req;
    }
  }
 
  
  // STUDENT MAY STOP READING HERE ...
  
  /**
   * Procsss command line arguments
   */
  
  static class Args {
    String           mainClassName;
    String[]         args;
    OptionReferrer[] optionReferrers;
    
    /**
     * Create args instance.
     *
     * @param args array of command line argument strings.
     */
    
    Args (String mainClassName, String[] args, OptionReferrer[] optionReferrers) {
      this.mainClassName=mainClassName; this.args=args; this.optionReferrers=optionReferrers;
    }
    
    /** 
     * Contains a reference to an option.  Useful to allow enums to describe an option, 
     * because enums can not extend a class and thus can not extend Args.Option, which 
     * would be the desired behaviour.
     */
    
    interface OptionReferrer {
      public Option getOption();
    }
     
    
    /**
     * Description of a command-line option.
     */
    
    static class Option {
      enum Type {BOOLEAN, INTEGER};
      
      final String string;
      final Type   type;
      final Object defaultValue;
      final String description;
      
      Option (String string, String description) {
        this.string=string; this.type=Type.BOOLEAN; this.defaultValue=null; this.description=description;
      }
      Option (String string, Integer defaultValue, String description) {
        this.string=string; this.type=Type.INTEGER; this.defaultValue=defaultValue; this.description=description;
      }
    }
    
    /**
     * Deterine whether command line argumnets contain specified option.
     *
     * @param  option option to check
     * @return        true iff option.string is on the command line
     */
    
    boolean contains (OptionReferrer optionReferrer) {
      Option option = optionReferrer.getOption();
      for (int i=0; i<args.length; i++)
        if (option.string.startsWith (args[i]))
          return true;
      return false;
    }
    
    /**
     * Get the int value of specified command line argument, if present and if int value allowed.
     *
     * @param option          option to check
     * @return                value provided on command line for specified option
     * @throws UsageException if option is not present, if it does not allow a value, 
     *                        or if command-line value is missing or malformed
     */
    
    int intValue (OptionReferrer optionReferrer) throws UsageException {
      Option option = optionReferrer.getOption();
      if (option.type==Option.Type.INTEGER) {
        for (int i=0; i<args.length; i++)
          if (option.string.startsWith (args[i]))
            try {
              return Integer.valueOf (args[i+1]);
            } catch (ArrayIndexOutOfBoundsException aioobe) {
              throw new UsageException();
            } catch (NumberFormatException nfe) {
              throw new UsageException();
            }
        if (option.defaultValue!=null)
          return (Integer) option.defaultValue;
        else
          throw new UsageException();
      } else
        throw new UsageException();
    }
    
    /**
     * An exception used to indicate a command-line sytax error whose message value is the usage string.
     */
    
    class UsageException extends Exception {
      @Override public String getMessage() {
        String str = String.format ("usage: java %s ", mainClassName);
        int    maxLength=0;
        for (OptionReferrer opRef : optionReferrers) {
          Option op  = opRef.getOption();
          String opt = op.string;
          maxLength  = Math.max (maxLength, op.string.length());
          switch (op.type) {
            case INTEGER:
              opt = opt.concat (" n");
              break;
            default:
          }
          str = str.concat (opt.concat (" "));
        }
        str = str.concat ("\n");
        String fmt = String.format ("    %%-%ds %%s", maxLength);
        for (OptionReferrer opRef : optionReferrers) {
          Option op  = opRef.getOption();
          String lin = String.format (fmt, op.string, op.description);
          if (op.defaultValue!=null) {
            switch (op.type) {
              case INTEGER:
                lin = lin.concat (String.format (" (default %d)", (Integer) op.defaultValue));
                break;
              default:
            }
          }
          str = str.concat (lin.concat ("\n"));
        }
        return str;        
      }
    }
  }
}
